<html xmlns="http://www.w3.org/1999/html">

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.16.1/vis.css" type="text/css" />
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.16.1/vis-network.min.js"> </script>
    <center>
        <h1 id="heading">anfektelse (1929-1965)</h1>
    </center>


    <!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->

    <style type="text/css">
       #mynetwork {
            width: 65%;
            height: 90%;

            margin-right: 2%;

            height: {
                    {
                    height
                }
            }

            ;

            background-color: {
                    {
                    bgcolor
                }
            }

            ;
            border: 1px solid lightgray;
            position: relative;
            float: left;
        }

            {
            % if nodes|length>100 and physics_enabled %
        }

        #loadingBar {
            position: absolute;
            top: 0px;
            left: 0px;

            width: {
                    {
                    width
                }
            }

            ;

            height: {
                    {
                    height
                }
            }

            ;
            background-color:rgba(200, 200, 200, 0.8);
            -webkit-transition: all 0.5s ease;
            -moz-transition: all 0.5s ease;
            -ms-transition: all 0.5s ease;
            -o-transition: all 0.5s ease;
            transition: all 0.5s ease;
            opacity:1;
        }

        #bar {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 20px;
            height: 20px;
            margin: auto auto auto auto;
            border-radius: 11px;
            border: 2px solid rgba(30, 30, 30, 0.05);
            background: rgb(0, 173, 246);
            /* Old browsers */
            box-shadow: 2px 0px 4px rgba(0, 0, 0, 0.4);
        }

        #border {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 500px;
            height: 23px;
            margin: auto auto auto auto;
            box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        #text {
            position: absolute;
            top: 8px;
            left: 530px;
            width: 30px;
            height: 50px;
            margin: auto auto auto auto;
            font-size: 22px;
            color: #000000;
        }

        div.outerBorder {
            position: relative;
            top: 400px;
            width: 600px;
            height: 44px;
            margin: auto auto auto auto;
            border: 8px solid rgba(0, 0, 0, 0.1);
            background: rgb(252, 252, 252);
            /* Old browsers */
            background: -moz-linear-gradient(top, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* FF3.6+ */
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, rgba(252, 252, 252, 1)), color-stop(100%, rgba(237, 237, 237, 1)));
            /* Chrome,Safari4+ */
            background: -webkit-linear-gradient(top, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* Chrome10+,Safari5.1+ */
            background: -o-linear-gradient(top, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* Opera 11.10+ */
            background: -ms-linear-gradient(top, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* IE10+ */
            background: linear-gradient(to bottom, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* W3C */
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fcfcfc', endColorstr='#ededed', GradientType=0);
            /* IE6-9 */
            border-radius: 72px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);
        }

            {
            % endif %
        }

            {
            % if conf %
        }

        #config {
            float: left;
            width: 400px;
            height: 600px;
        }

            {
            % endif %
        }

            {
            % if tooltip_link %
        }

        /* position absolute is important and the container has to be relative or absolute as well. */
        div.popup {
            position: absolute;
            top: 0px;
            left: 0px;
            display: none;
            background-color: #f5f4ed;
            -moz-border-radius: 3px;
            -webkit-border-radius: 3px;
            border-radius: 3px;
            border: 1px solid #808074;
            box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);
        }



        /* hide the original tooltip */


        .vis-tooltip {
            position: absolute;
        }

        #config {
            display: none;

        }

            {
            % endif %
        }

        #custom_wugs {
            height: 90%;
            width: 30%;
            overflow: scroll;
        }

        #custom_wugs>* {
            padding: 1%;
            margin-left: 2%;
        }






        .help-tip {
            position: absolute;
            top: 18px;
            right: 18px;
            text-align: center;
            background-color: #E55B0A;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 26px;
            cursor: default;
        }

        .help-tip:before {
            content: '?';
            font-weight: bold;
            color: #fff;
        }

        .help-tip:hover p {
            display: block;
            transform-origin: 100% 0%;

            -webkit-animation: fadeIn 0.3s ease-in-out;
            animation: fadeIn 0.3s ease-in-out;

        }

        .help-tip p {
            /* The tooltip */
            display: none;
            text-align: left;
            background-color: #1E2021;
            padding: 20px;
            width: 800px;
            position: absolute;
            border-radius: 3px;
            box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
            right: 16px;
            color: #FFF;
            font-size: 13px;
            line-height: 1.4;
        }

        .help-tip p:before {
            /* The pointer of the tooltip */
            position: absolute;
            content: '';
            width: 0;
            height: 0;
            border: 6px solid transparent;
            border-bottom-color: #1E2021;
            right: 10px;
            top: -12px;
        }

        .help-tip p:after {
            /* Prevents the tooltip from being hidden */
            width: 100%;
            height: 40px;
            content: '';
            position: absolute;
            top: -40px;
            left: 0;
        }


        /* CSS animation */

        @-webkit-keyframes fadeIn {
            0% {
                opacity: 0;
                transform: scale(0.6);
            }

            100% {
                opacity: 100%;
                transform: scale(1);
            }
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 100%;
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .loading-icon {
            position: absolute;
            top: 40%;
            left: 30%;
            transform: translate(-50%, -50%);
            border: 16px solid #f3f3f3; /* Light grey */
            border-top: 16px solid red;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
            visibility: hidden;
        }

        #custom_wugs {
            font-size: smaller;
        }

        .shifted {
            margin-left: 3%;
        }

        .bold {
            font-weight: bold;
        }

        #fillSD {
            margin-bottom: 0;
            padding-bottom: 0;
        }

    </style>

</head>

<body>
     <div id="loader" style="display: none"></div>

    <div id="mynetwork"></div>
    
    

    <div id="custom_wugs">



        <div class="help-tip">
            <p><em>General</em><br />
           Firefox is the recommended browser for this application. For large graphs, loading time may vary. This application is under development. Feedback is appreciated. The code, from which you can generate your own graphs, can be found here:  <a href="https://github.com/Garrafao/WUGs/" target="_blank" style="color: white">WUGs repository</a><br /><br /><br />
                <em>Statistics</em><br />
            The statistics section gets updated as the filters are used. For in-depth stats, refer to the stats dropdowns on the bottom.<br /><br /><br />
                <em>Edge & node filters</em><br />
            Edge weights are calculated as the mean of all annotations of the node pair.
            Nodes with noisy data appear black and have -1 as their label. Both the noisy nodes and edges with wrongly calculated weights can be filtered out.
            Edge and node filters are interlinked and should show the desired selection. While one filter is being calculated, the page will prevent you from selecting another filter.<br /><br /><br />
                <em>Annotators filter</em><br />
            The annotators filter resets all other filters and shows the initial graph, but only edges the selected annotators have annotated.</p>
        </div>

        <div class="infoContainer">
            <h4>Info: </h4>
            <div id="clusterInfo"></div>
            <h4>Statistics:</h4>
            <div id="statistics"></div>
            <p id="fillMean">Edge weight mean: </p>
            <p id="fillSD">Edge weight standard deviation: </p>
        </div>
        <div class ="edgeFilterContainer">
            <h4>Edge filters: </h4>

            <label for="checkboxNaN">Show NaN edges </label>
            <input type="checkbox" id="checkboxNaN" onclick="filterNaN()">
            <br><br>
            <div class="slideContainer" style="display: block; clear: both">
                <label for="slider-min" style="display: block">Min weight: <span id="sliderValueDisplayMin" style="display: inline-block">1</span></label>
                <input type="range" min="1" max="4" value="1" class="slider-load" id="slider-min">
                <label for="slider" style="display: block">Max weight: <span id="sliderValueDisplay" style="display: inline-block">4</span></label>
                <input type="range" min="1" max="4" value="4" class="slider-load" id="slider">
            </div>
        </div>




        <div class="nodeFilterContainer">
            <h4>Node filters: </h4>

            <label for="checkboxNoiseLabels">Show noise cluster</label>
            <input type="checkbox" id="checkboxNoiseLabels" onclick="filterNoiseLabels()">
            <br><br>
            <form onsubmit="dateFilter();return false">
                <label for="minPicker">From date: </label>
                <select class="picker" id="minPicker"></select>
                <label for="maxPicker">to date: </label>
                <select class="picker" id="maxPicker"></select>
                <input type="submit" value="Filter">
            </form>

            <label for="groupPicker">Grouping: </label>
            <select  class="select-load" id="groupPicker">
                <option>All</option>
                <option>1</option>
                <option>2</option>
            </select>
            <div class="loading-icon"></div>
        </div>

        <div id="annotatorsContainer"></div>

        <div class="detailsContainer">
            <details id="stats">
                <summary class="bold">Stats</summary>
                <table id="stats-table"></table>
            </details>
            <details id="statsGroupings">
                <summary class="bold">Grouping stats</summary>
                <table id="stats-groupings-table"></table>
            </details>
            <details id="statsAgreement">
                <summary class="bold">Agreement stats</summary>
                <table id="stats-agreement-table"></table>
            </details>
            <details id="statsPlotting">
                <summary class="bold">Plotting stats</summary>
                <table id="stats-plotting-table"></table>
            </details>
            <details id="statsDataJoint">
                <summary class="bold">Annotator data</summary>
            </details>
        </div>

    </div>

    <div id="config">

    </div>

    
     <!--<script type="text/javascript" src="../stats.js"></script>
     <script type="text/javascript" src="../stats_agreement.js"></script>
     <script type="text/javascript" src="../stats_groupings.js"></script>
     <script type="text/javascript" src="../stats_plotting.js"></script>
     <script type="text/javascript" src="../data_joint.js"></script>-->

    <script type="text/javascript">
        // initialize global variables.
        var edges;
        var nodes;
        var network;
        var container;
        var options, data;


        // This method is responsible for drawing the graph, returns the drawn network
        function drawGraph() {
            var container = document.getElementById('mynetwork');

            

            // parsing and collecting nodes and edges from the python
            nodes = new vis.DataSet([{"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_31", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eDe fortviler nemlig over sig selv, og Guds ord gj\u00f8r sin\u003cbr\u003egjerning i dem og virker beven for Gud (pavorem Dei). 1 ) Den allerede\u003cbr\u003ei Ps I betonte selvfortvilelse fremhever Luther nu i R som den rette\u003cbr\u003eog gode frukt av predest.laeren. Herrens ord i Rom. 9, 15 er, sier\u003cbr\u003eLuther, et h\u00e5rdt svar for de hovmodige og kloke, men s\u00f8tt og kjaert\u003cbr\u003efor de saktmodige og ydmyke, fordi disse fortviler over sig selv.\u003cbr\u003eDerfor tar Gud sig av dem. 2 ) Hvis da nogen er altfor engstelig for\u003cbr\u003eat han ikke er utvalgt, eller han kommer i \u003cb\u003eanfektelse\u003c/b\u003e m. h. t.\u003cbr\u003esin egen utvelgelse (tentatur de electione sui), s\u00e5 skal han takke for\u003cbr\u003es\u00e5dan angst og glede sig over den, da han med tillit er forvisset om\u003cbr\u003eat Gud ikke kan lyve, som uttaler ordene i Ps. 51, 19. F\u00f8lgelig skal\u003cbr\u003ehan freidig (audacter) styrte sig inn i den forjettende Guds sannhet,\u003cbr\u003eog vende sig fra den skremmende Guds forutviden; da vil han vaere\u003cbr\u003esalig og utvalgt. 8 ) P\u00e5 tilsvarende m\u00e5te hevder Luther, at de som\u003cbr\u003eforherdes overfor Guds ord (ad verbum Dei indurantur) og er selvsikre,\u003cbr\u003edermed har et meget d\u00e5rlig tegn (pessimum signum habent). 4 ) Her er\u003cbr\u003eif\u00f8lge Luther en avgjort forskjell mellem de forkastede og de\u003cbr\u003eutvalgte.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_31\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -674.6288342101205, "y": 198.54133024530103}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_30", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eDet er for \u00e5 ydmyke de utvalgte og laere dem \u00e5 sette all sin\u003cbr\u003elit til hans barmhjertighet alene og opgi all stolen p\u00e5 egen vilje og\u003cbr\u003eegne gjerninger, at Gud lar dem komme i fortvilelse og\u003cbr\u003e\u003cb\u003eanfektelse\u003c/b\u003e og bli forfulgt av djevelen, verden og kj\u00f8det, idet\u003cbr\u003ehan selv setter disse i bevegelse (quos excitat). 8 ) Derfor opvekker\u003cbr\u003eGud endog ofte \u00abog saerlig i v\u00e5r tid\u00bb (et precipue nostro tempore)\u003cbr\u003edjevelen til \u00e5 styrte de utvalgte i forferdelige synder (horrenda\u003cbr\u003epeccata) og en tidlang ha herred\u00f8mme over dem. Og allikevel f\u00f8rer han\u003cbr\u003edem gjennem alt dette og befrir dem til slutt imot deres forventning,\u003cbr\u003emens de selv som fortvilede sukker over sin ondskap og sin mangel p\u00e5\u003cbr\u003evilje til det gode. 4 ) S\u00e5ledes vil da ordene om Faraos forherligelse\u003cbr\u003evise, at frelsen beror p\u00e5 Guds forbarmelse og ikke p\u00e5 menneskets vilje\u003cbr\u003e(quod solius\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_30\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -917.6381961177572, "y": -230.5285358783627}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_17", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eSaerlig er det vel derved etter v. 12 \u00e5 tenke p\u00e5 folk som\u003cbr\u003epreker falsk frihet fra loven (sml. 2 Tim. 3, 1 fig.; 2 Pet. 2, 1\u003cbr\u003efig). S\u00e5ledes vil (v. 12) \u00aburettferdigheten\u00bb (sml. til 7, 23) ta\u003cbr\u003eoverhand i menigheten, og f\u00f8lgen derav blir da at kristenlivet\u003cbr\u003e\u00f8delegges hos de kristnes store flerhet, idet kjaerligheten blir kold.\u003cbr\u003eJesus forutsier alts\u00e5 her en stadig tiltagende utartning innen\u003cbr\u003emenigheten, som selvf\u00f8lgelig ogs\u00e5, liksom hatet og forf\u00f8lgelsen\u003cbr\u003eutenfra, vil medf\u00f8re \u003cb\u003eanfektelse\u003c/b\u003e og fristelse for alle sanne\u003cbr\u003edisipler.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_17\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -168.6391100600658, "y": -99.42470598334464}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_48", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eUnder alle disse \u003cb\u003eanfektelser\u003c/b\u003e stod fruens h\u00f8ye person i\u003cbr\u003euavbrutt travelhet b\u00f8yd som en kran over kassen med byvarene, som var\u003cbr\u003el\u00f8ftet inn p\u00e5 kj\u00f8kkengulvet. Dunker, vidjekurver med h\u00f8y i, sm\u00e5sekker\u003cbr\u003eog en uendelighet av pakker i gr\u00e5tt omslag ombundet med hyssing, sm\u00e5\u003cbr\u003eog store, forsvant efterh\u00e5nden i deres forskjellige\u003cbr\u003eoppbevaringssteder, like til den siste, sekken med det fine hvetemel,\u003cbr\u003esom ble b\u00e5ret inn av Stor-Ola og satt hen for seg i melkassen inne i\u003cbr\u003espiskammeret.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_48\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": 864.133914684794, "y": 225.5142160148771}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_32", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eS\u00e5 kunde han ut av egen erfaring tale om disse\u003cbr\u003e\u003cb\u003eanfektelser\u003c/b\u003e og om veier og midler til \u00e5 seire over dem. Det\u003cbr\u003esp\u00f8rsm\u00e5l som p\u00e5 dette omr\u00e5de aller mest pinte Luthers sjel, og som\u003cbr\u003eatter og atter m\u00e5tte melde sig, var det allerede foran ber\u00f8rte om ens\u003cbr\u003eegen personlige predestinasjon, hvorvidt man selv er med blandt de\u003cbr\u003eutvalgtes tall eller ikke. M. h. t. dette sp\u00f8rsm\u00e5l viser Luther hen\u003cbr\u003etil Paulus, som ved en \u00e5penbaring var blitt forvisset om \u00e5 vaere et\u003cbr\u003evas electionis. 7 ) Nu er ogs\u00e5 vi alle, hevder Luther, forvisset om at\u003cbr\u003eder er dem som er utvalgt (de electis et nos omnes certi\u003cbr\u003esumus).\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_32\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": 173.32122127707834, "y": 614.3104780674558}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_33", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eS\u00e5danne gudsbespottelser, som djevelen voldsomt fremtvinger av\u003cbr\u003emennesker mot deres vilje, kan endog undertiden klinge kjaert i Guds\u003cbr\u003e\u00f8re, som et halleluja og en jubelsang. Ti jo slemmere gudsbespottelsen\u003cbr\u003eer, desto kjaerere er den Gud, vel \u00e5 merke n\u00e5r hjertet f\u00f8ler at det\u003cbr\u003eikke vil denne bespottelse, men er i stor angst over \u00e5 ha beg\u00e5tt den.\u003cbr\u003eTi en s\u00e5dan pavor mali er et tydelig tegn p\u00e5 dette menneskes gode\u003cbr\u003ehjerte. 1 ) Men nettop med disse \u003cb\u003eanfektelser\u003c/b\u003e for \u00f8ie advarer\u003cbr\u003eLuther mot overhodet \u00e5 beskjeftige sig med\u003cbr\u003epredestinasjonslaeren.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_33\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -182.24512296024946, "y": 327.8129090040723}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_43", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eMen mere allsidig er sjelesorgen i Ps 11, idet Luther her b\u00e5de\u003cbr\u003egir de utf\u00f8rlige advarsler mot predest.\u003cb\u003eanfektelsen\u003c/b\u003e som\u003cbr\u003edjevelens verk og mot de dermed f\u00f8lgende synder, og tillike p\u00e5 en ennu\u003cbr\u003emere fremtredende m\u00e5te enn i R stiller Kristus inn i anfektelsen og\u003cbr\u003eviser hen til hans seier som en seier ogs\u00e5 for oss. Forskjellig fra R\u003cbr\u003eer Ps II enn videre ogs\u00e5 derved, at mens i R saerlig kjaerligheten\u003cbr\u003erepresenterer den restl\u00f8se hengivelse i Guds vilje, rykker i Ps II\u003cbr\u003etroen i forgrunnen som den makt hvorved seieren vinnes, idet sjelen\u003cbr\u003ekjemper med tro mot tro og fastholder tilliten til Guds rettferdighet\u003cbr\u003eogs\u00e5 n\u00e5r han ford\u00f8mmer.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_43\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -1036.0305066430076, "y": 543.4744596500158}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_11", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eHan h\u00f8rte vel ikke til de prester som hadde altfor farlige\u003cbr\u003e\u003cb\u003eanfektelser\u003c/b\u003e og vel ikke til d6 diktere som holdt altfor mange\u003cbr\u003edommedager over sig selv.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_11\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -1255.3602631363535, "y": 891.7060525217769}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_56", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eDiktet viser hans tvil og samvittighetsnag, som ogs\u00e5 brer sig\u003cbr\u003eut blandt hans menn og symboliserer sig i \u00abvita frun\u00bb som g\u00e5r igjen.\u003cbr\u003eEfter store \u003cb\u003eanfektelser\u003c/b\u003e kommer han til slutt ved s\u00f8nnens hjelp\u003cbr\u003etil det resultat at det er for folkets egen skyld han har rettet det\u003cbr\u003eblodige slag mot adelen.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_56\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": 273.4296676567731, "y": 1140.3166364384128}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_anfektelse_10", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u2014 Gamle venn, Gud gi dig seierrikt \u00e5 kjempe dig igjennem dine\u003cbr\u003e\u003cb\u003eanfektelser\u003c/b\u003e i Jesu navn. Min tro og tr\u00f8st, mitt h\u00e5p og b\u00f8nn, o\u003cbr\u003eHerre, du formere!\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_10\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -1427.2678844281143, "y": -266.2262908011752}, {"color": "k", "date": "1929", "id": "1929-1965_anfektelse_51", "label": "-1", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eA.t personligheten bevarer sin enhet tross \u003cb\u003eanfektelser\u003c/b\u003e\u003cbr\u003ebetegnes som eller rennet.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_anfektelse_51\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -306.67859657696533, "y": 1221.7419446383633}]);
        edges = new vis.DataSet([{"color": "black", "from": "1929-1965_anfektelse_31", "label": "3/-/0", "to": "1929-1965_anfektelse_56", "weight": 3.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_31", "label": "4/4/4", "to": "1929-1965_anfektelse_33", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_31", "label": "4/-/4", "to": "1929-1965_anfektelse_30", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_31", "label": "4/3/4", "to": "1929-1965_anfektelse_11", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_31", "label": "3/3/0", "to": "1929-1965_anfektelse_48", "weight": 3.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_31", "label": "4/4/4", "to": "1929-1965_anfektelse_17", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_31", "label": "-/3/4", "to": "1929-1965_anfektelse_10", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_31", "label": "-/3/4", "to": "1929-1965_anfektelse_43", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_31", "label": "-/-/4", "to": "1929-1965_anfektelse_32", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_30", "label": "4/3/4", "to": "1929-1965_anfektelse_11", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_30", "label": "4/0/4", "to": "1929-1965_anfektelse_33", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_30", "label": "3/-/0", "to": "1929-1965_anfektelse_48", "weight": 3.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_30", "label": "3/-/0", "to": "1929-1965_anfektelse_51", "weight": 3.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_30", "label": "4/-/-", "to": "1929-1965_anfektelse_10", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_30", "label": "4/-/4", "to": "1929-1965_anfektelse_43", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_30", "label": "4/0/4", "to": "1929-1965_anfektelse_17", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_30", "label": "3/-/4", "to": "1929-1965_anfektelse_56", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_30", "label": "4/4/4", "to": "1929-1965_anfektelse_32", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_17", "label": "4/4/4", "to": "1929-1965_anfektelse_32", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_17", "label": "3/-/4", "to": "1929-1965_anfektelse_56", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_17", "label": "3/-/0", "to": "1929-1965_anfektelse_51", "weight": 3.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_17", "label": "3/4/0", "to": "1929-1965_anfektelse_48", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_17", "label": "4/-/4", "to": "1929-1965_anfektelse_11", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_17", "label": "4/-/4", "to": "1929-1965_anfektelse_33", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_17", "label": "-/4/4", "to": "1929-1965_anfektelse_10", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_17", "label": "-/-/4", "to": "1929-1965_anfektelse_43", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_48", "label": "4/-/0", "to": "1929-1965_anfektelse_56", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_48", "label": "4/-/0", "to": "1929-1965_anfektelse_51", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_48", "label": "3/3/0", "to": "1929-1965_anfektelse_32", "weight": 3.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_48", "label": "3/-/0", "to": "1929-1965_anfektelse_11", "weight": 3.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_32", "label": "-/3/4", "to": "1929-1965_anfektelse_43", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_32", "label": "-/3/4", "to": "1929-1965_anfektelse_11", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_32", "label": "-/4/0", "to": "1929-1965_anfektelse_51", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_32", "label": "-/4/4", "to": "1929-1965_anfektelse_33", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_32", "label": "-/-/4", "to": "1929-1965_anfektelse_56", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_33", "label": "3/-/4", "to": "1929-1965_anfektelse_56", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_33", "label": "4/4/0", "to": "1929-1965_anfektelse_51", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_33", "label": "4/3/4", "to": "1929-1965_anfektelse_11", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_33", "label": "-/-/4", "to": "1929-1965_anfektelse_10", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_51", "label": "3/4/-", "to": "1929-1965_anfektelse_10", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_51", "label": "-/4/0", "to": "1929-1965_anfektelse_11", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_51", "label": "-/4/0", "to": "1929-1965_anfektelse_43", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_43", "label": "4/-/4", "to": "1929-1965_anfektelse_10", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_43", "label": "4/3/-", "to": "1929-1965_anfektelse_11", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_43", "label": "-/-/4", "to": "1929-1965_anfektelse_56", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_11", "label": "3/-/4", "to": "1929-1965_anfektelse_56", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_anfektelse_11", "label": "-/-/4", "to": "1929-1965_anfektelse_10", "weight": 4.0, "width": 4}, {"color": "lightgray", "from": "1929-1965_anfektelse_31", "label": "-/-/0", "to": "1929-1965_anfektelse_51", "weight": NaN, "width": 1.0}, {"color": "lightgray", "from": "1929-1965_anfektelse_48", "label": "-/-/0", "to": "1929-1965_anfektelse_43", "weight": NaN, "width": 1.0}, {"color": "lightgray", "from": "1929-1965_anfektelse_48", "label": "-/-/0", "to": "1929-1965_anfektelse_10", "weight": NaN, "width": 1.0}, {"color": "lightgray", "from": "1929-1965_anfektelse_32", "label": "-/-/0", "to": "1929-1965_anfektelse_10", "weight": NaN, "width": 1.0}, {"color": "lightgray", "from": "1929-1965_anfektelse_33", "label": "-/0/0", "to": "1929-1965_anfektelse_43", "weight": NaN, "width": 1.0}, {"color": "lightgray", "from": "1929-1965_anfektelse_51", "label": "-/-/0", "to": "1929-1965_anfektelse_56", "weight": NaN, "width": 1.0}]);

        // adding nodes and edges to the graph
        data = { nodes: nodes, edges: edges };

        var options = {
    "configure": {
        "enabled": true,
        "filter": [
            "nodes",
            "edges"
        ]
    },
    "edges": {
        "color": {
            "inherit": false
        },
        "smooth": {
            "enabled": false,
            "type": "continuous"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": false,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

        

        
        // if this network requires displaying the configure window,
        // put it in its div
        options.configure["container"] = document.getElementById("config");
        

        network = new vis.Network(container, data, options);

        


        

        return network;

    }

        drawGraph();


        let nodesInTimePeriod = new Set();
        let edgesInTimePeriod = new Set();
        let edgesBelowWeight = new Set();
        let nodesInGrouping = new Set();
        let edgesInGrouping = new Set();
        let edgesToBeShown = new Set();
        let nodesToBeShown = new Set();

        edges.forEach(function (edge) {
            edgesBelowWeight.add(edge.id);
            edgesInGrouping.add(edge.id);
            edgesInTimePeriod.add(edge.id);
            edgesToBeShown.add(edge.id);
        })

        nodes.forEach(function (node) {
            nodesInTimePeriod.add(node.id);
            nodesInGrouping.add(node.id);
            nodesToBeShown.add(node.id);
        })


        function showEdges() {
            edgesToBeShown.forEach(function (edge) {
                edge.hidden = false;
                edges.update(edge);
            })
        }

        //Missing the loading icon
        //slider code from pyvis filter example
        // Handler event when slider changes

        let slider = document.getElementById('slider');
        let sliderMin = document.getElementById('slider-min');
        let sliderDisplay = document.getElementById('sliderValueDisplay');
        let sliderMinDisplay = document.getElementById('sliderValueDisplayMin');

        sliderDisplay.innerHTML = "4";
        sliderMinDisplay.innerHTML = "1";

        function weightFilter() {
            console.log("weight filter got called");
            // Get the value of the slider
            let sliderValue = slider.value;
            let sliderMinValue = sliderMin.value;

            // Display the selected value next to slider
            sliderDisplay.innerHTML = sliderValue;
            sliderMinDisplay.innerHTML = sliderMinValue;

            // Loop through the edges
            edges.forEach(function (edge) {
                // Check if the edge should be displayed based on its weight
                if (edge.weight <= sliderValue && edge.weight >= sliderMinValue) {
                    if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden) {
                        edgesBelowWeight.add(edge.id);
                        edge.hidden = false;
                        edges.update(edge);
                    }
                    // Edge should be displayed
                    // Unhide edge if it's hidden and update DataSet

                } else if (isNaN(edge.weight)) {
                    //console.log("its NaN")
                } else {

                    // Edge should not be displayed
                    // Hide edge if not already hidden and update DataSet
                    if (!edge.hidden) {
                        edgesBelowWeight.delete(edge.id);
                        edge.hidden = true;
                        edges.update(edge);
                    }
                }
            });


            calcMean();
        }



        //code for node date filter
        let dates = [];
        nodes.forEach(function (node) {
            date = node.date;
            if (!dates.includes(date)) {
                dates.push(date);
            }
        });
        dates.sort();


        //code for date slider
        let minDate = 10000;
        let maxDate = 0;

        let minPicker = document.getElementById('minPicker');
        let maxPicker = document.getElementById('maxPicker');

        if (!minPicker.hasChildNodes()) {
            dates.forEach(function (date) {
                if (Number(date) < minDate) {
                    minDate = Number(date);
                }
                if (Number(date) > maxDate) {
                    maxDate = Number(date);
                }


                let option = document.createElement('option');
                option.text = date;
                option.value = date;

                let option2 = document.createElement('option');
                option2.text = date;
                option2.value = date;

                minPicker.append(option);
                maxPicker.append(option2);

            })
        } else {
            minDate = Number(dates[0]);
            maxDate = Number(dates[dates.length-1]);
        }
        maxPicker.selectedIndex = dates.length - 1;



        function showSelectLoad() {
            return new Promise(function (resolve) {
                loadingIcon.style.visibility = 'visible';
                resolve();
            });
        }

        function hideSelectLoad() {
            return new Promise(function (resolve) {
                loadingIcon.style.visibility = 'hidden';
                resolve();
            });
        }



        const loadingIcon = document.querySelector('.loading-icon');
        const select = document.querySelector('.select-load');

        select.addEventListener('change', function () {
            showSelectLoad();
            setTimeout(selectGroup, 1000);


            setTimeout(hideSelectLoad, 1000);


        });

        //const slider_load = document.querySelector('.slider-load');

         slider.addEventListener('change', function() {
            showSelectLoad();
            setTimeout(weightFilter,1000);


            setTimeout(hideSelectLoad, 1000);


        });

         sliderMin.addEventListener('change', function() {
            showSelectLoad();
            setTimeout(weightFilter,1000);


            setTimeout(hideSelectLoad, 1000);


        });

        let groupPicker = document.getElementById('groupPicker');
        groupPicker.selectedIndex = 0;
        let minValue = minPicker.value;
        let maxValue = maxPicker.value;

        function selectGroup() {
            return new Promise(function (resolve, reject) {
                let selectValue = document.getElementById('groupPicker').value;

                console.log("grouping value: " + selectValue);

                if (selectValue == 1) {
                    nodes.forEach(function (node) {


                        if (node.title.includes("grouping: 1") && Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                            node.hidden = false;
                            nodes.update(node);
                        } else {
                            node.hidden = true;
                            nodes.update(node);
                        }
                    })
                } else if (selectValue == 2) {
                    nodes.forEach(function (node) {
                        if (node.title.includes("grouping: 2") && Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                            node.hidden = false;
                            nodes.update(node);
                        } else {
                            node.hidden = true;
                            nodes.update(node);
                        }
                    })
                } else {
                    nodes.forEach(function (node) {
                        if (Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                            node.hidden = false;
                            nodes.update(node);
                        } else {
                            node.hidden = true;
                            nodes.update(node);
                        }
                    })
                }
                loadingIcon.style.visibility = 'hidden';

                edges.forEach(function (edge) {
                    if (isNaN(edge.weight)) {
                        if (showNaNEdges && !nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden) {

                            edge.hidden = false;
                            edges.update(edge);
                        } else {
                            edge.hidden = true;
                            edge.hidden = true;
                            edges.update(edge);
                        }
                    } else if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden && !isNaN(edge.weight)) {
                        edgesInGrouping.add(edge.id);
                        edge.hidden = false;
                        edges.update(edge);
                    } else {
                        edgesInGrouping.delete(edge.id);
                        edge.hidden = true;
                        edges.update(edge);
                    }


                })
                loadingIcon.style.visibility = 'hidden';
                calcMean();
                updateClusterDistribution();
                resolve();
            });

        }

        function dateFilter() {
            showSelectLoad();
            setTimeout(pickDates, 1000);


            setTimeout(hideSelectLoad, 2000);


        }

        function pickDates() {
            loadingIcon.style.visibility = 'visible';

            let selectValue = document.getElementById('groupPicker').value;
            minValue = minPicker.value;
            maxValue = maxPicker.value;

            //console.log("showing dates between " + minValue + " and " + maxValue);

            if (selectValue == 1) {
                nodes.forEach(function (node) {


                    if (node.title.includes("grouping: 1") && Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                        node.hidden = false;
                        nodes.update(node);
                    } else {
                        node.hidden = true;
                        nodes.update(node);
                    }
                })
            } else if (selectValue == 2) {
                nodes.forEach(function (node) {
                    if (node.title.includes("grouping: 2") && Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                        node.hidden = false;
                        nodes.update(node);
                    } else {
                        node.hidden = true;
                        nodes.update(node);
                    }
                })
            } else {
                nodes.forEach(function (node) {
                    if (Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                        node.hidden = false;
                        nodes.update(node);
                    } else {
                        node.hidden = true;
                        nodes.update(node);
                    }
                })
            }

            edges.forEach(function (edge) {


                if (isNaN(edge.weight) && !showNaNEdges) {

                } else if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden && isNaN(edge.weight)){
                    edgesInTimePeriod.add(edge.id);
                    edge.hidden = false;
                    edges.update(edge);
                } else if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden && edge.weight >= sliderMin.value && edge.weight <= slider.value) {
                    edgesInTimePeriod.add(edge.id);
                    edge.hidden = false;
                    edges.update(edge);
                } else {
                    edgesInTimePeriod.delete(edge.id);
                    edge.hidden = true;
                    edges.update(edge);
                }


            })
            loadingIcon.style.visibility = 'hidden'


            calcMean();
            updateClusterDistribution();

        }

        let showNaNEdges = true;

        function filterNaN() {
            showSelectLoad();
            setTimeout(selectNaN, 1000);


            setTimeout(hideSelectLoad, 1000);

        };

        const checkboxNaN = document.getElementById("checkboxNaN");

        function selectNaN() {
            if (checkboxNaN.checked) {

                showNaNEdges = true;
                edges.forEach(function (edge) {
                    if (isNaN(edge.weight)) {
                        edge.hidden = false;
                        edges.update(edge);
                        pickDates();
                    }
                });
            } else {
                showNaNEdges = false;
                edges.forEach(function (edge) {
                    if (isNaN(edge.weight)) {
                        edge.hidden = true;
                        edges.update(edge);
                    }
                });
            }


        }


        const checkboxNoiseLabels = document.getElementById("checkboxNoiseLabels");

        document.getElementById("checkboxNaN").checked = true;
        document.getElementById("checkboxNoiseLabels").checked = true;

        let showNoiseLabels = true;

        function filterNoiseLabels() {
            showSelectLoad();
            setTimeout(selectNoiseLabels, 1000);


            setTimeout(hideSelectLoad, 1000);
        }

        function selectNoiseLabels() {
            if (checkboxNoiseLabels.checked) {

                showNoiseLabels = true;

                nodes.forEach(function (node) {
                    if (Number(node.label) == -1) {
                        node.hidden = false;
                        nodes.update(node);
                    }
                })

                edges.forEach(function (edge) {
                    if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden) {
                        if (isNaN(edge.weight) && !showNaNEdges) {
                            edge.hidden = true;
                            edges.update(edge);

                        } else {
                            edge.hidden = false;
                            edges.update(edge);
                        }
                    }
                })

            } else {

                showNoiseLabels = false;

                nodes.forEach(function (node) {
                    if (Number(node.label) == -1) {

                        node.hidden = true;

                        nodes.update(node);
                    }
                })

                edges.forEach(function (edge) {
                    if (nodes.get(edge.to).hidden || nodes.get(edge.from).hidden || (isNaN(edge.weight) && !showNaNEdges)) {

                        edge.hidden = true;
                        edges.update(edge);

                    }
                })

            }
            updateClusterDistribution();
        }


        let fillMean = document.getElementById("fillMean");
        let fillSD = document.getElementById("fillSD");


        function calcMean() {
            let edgeValues = [];
            edges.forEach(function (edge) {
                if (!edge.hidden) {
                    let label = parseFloat(edge.weight);
                    if (!isNaN(label)) {
                        edgeValues.push(label);
                    }
                }
            })

            let mean = edgeValues.reduce((a, b) => a + b, 0) / edgeValues.length;
            let sd = dev(edgeValues, mean);
            if (isNaN(mean)) {
                mean = 0;
            }
            if (isNaN(sd)) {
                sd = 0;
            }
            mean = mean.toFixed(5);
            sd = sd.toFixed(5);

            fillMean.innerHTML = "Edge weight mean: ";
            fillSD.innerHTML = "Edge weight standard deviation: "

            fillMean.append(mean);
            fillSD.append(sd);

        }


        // Javascript program to calculate the standard deviation of an array

        function dev(arr, mean) {

            // Assigning (value - mean) ^ 2 to every array item
            arr = arr.map((k) => {
                return (k - mean) ** 2
            })


            // Calculating the sum of updated array
            let sum = arr.reduce((acc, curr) => acc + curr, 0);


            // Returning the standard deviation
            return Math.sqrt(sum / arr.length)
        }

        calcMean();


        let heading = document.getElementById("heading").innerHTML;
        let onlyLemma = heading.replace(/ .*/, '');

        //NEW

        // set up flag variables to track which scripts have been loaded successfully
        let statsLoaded = false;
        let statsGroupingsLoaded = false;
        let statsAgreementLoaded = false;
        let statsPlottingLoaded = false;
        let statsDataJointLoaded = false;

        let filteredStats = [];
        let filteredStatsGroupings = [];
        let filteredStatsAgreement = [];
        let filteredStatsPlotting = [];
        let filteredStatsDataJoint = [];

        let clusteringMethod;
        let cluster_freq_dist;
        let cluster_prob_dist;
        let noise_cluster_count;
        let clusterInfo;
        let statisticsDiv;
        let nodePosition;


        // create event listeners for each script to set the corresponding flag when loaded
        document.addEventListener('statsLoaded', function () {
            console.log('stats.js is fully loaded!');
            statsLoaded = true;
            checkAllScriptsLoaded();
        });

        document.addEventListener('statsGroupingsLoaded', function () {
            console.log('stats_groupings.js is fully loaded!');
            statsGroupingsLoaded = true;
            checkAllScriptsLoaded();
        });

        document.addEventListener('statsAgreementLoaded', function () {
            console.log('stats_agreement.js is fully loaded!');
            statsAgreementLoaded = true;
            checkAllScriptsLoaded();
        });

        document.addEventListener('statsPlottingLoaded', function () {
            console.log('stats_plotting.js is fully loaded!');
            statsPlottingLoaded = true;
            checkAllScriptsLoaded();
        });

        document.addEventListener('statsDataJointLoaded', function () {
            console.log('data_joint.js is fully loaded!');
            statsDataJointLoaded = true;
            checkAllScriptsLoaded();
        });

        // load each script with the same function
        function loadScript(scriptUrl, eventName) {
            const script = document.createElement('script');
            script.src = scriptUrl;
            script.type = 'text/javascript';

            script.addEventListener('load', function () {
                console.log(scriptUrl + ' loaded successfully');
                document.dispatchEvent(new Event(eventName));
            });

            script.addEventListener('error', function () {
                console.log('Failed to load ' + scriptUrl);
                checkAllScriptsLoaded();
            });

            document.body.appendChild(script);
        }

        // call the loadScript function for each script you want to load
        loadScript('../stats.js', 'statsLoaded');
        loadScript('../stats_groupings.js', 'statsGroupingsLoaded');
        loadScript('../stats_agreement.js', 'statsAgreementLoaded');
        loadScript('../stats_plotting.js', 'statsPlottingLoaded');
        loadScript('../data_joint.js', 'statsDataJointLoaded');

        // check if all scripts have been loaded, and execute the code that depends on them if they have
        function checkAllScriptsLoaded() {

            if (statsLoaded) {
                try {
                    filteredStats = stats.filter(row => row.lemma === onlyLemma);
                } catch (err) {
                    console.log('stats not found');
                }

                try {
                    generateTable(filteredStats, "stats");
                } catch (err) {
                    console.log('problem generating table with stats');
                }

                try {
                    clusteringMethod = filteredStats[0].algorithm;
                } catch (err) {
                    console.log('filteredStats[0] not found');
                }



            }

            if (statsGroupingsLoaded) {
                try {
                    filteredStatsGroupings = stats_groupings.filter(row => row.lemma === onlyLemma);
                } catch (err) {
                    console.log('stats_groupings not found');
                }

                try {
                    generateTable(filteredStatsGroupings, "statsGroupings");
                } catch (err) {
                    console.log('problem generating table with stats_groupings');
                }

                cluster_freq_dist = filteredStatsGroupings[0].cluster_freq_dist;
                cluster_prob_dist = filteredStatsGroupings[0].cluster_prob_dist;
            }

            if (statsAgreementLoaded) {
                try {
                    filteredStatsAgreement = stats_agreement.filter(row => row.data === onlyLemma);
                } catch (err) {
                    console.log('stats_agreement not found');
                }

                try {
                    generateTable(filteredStatsAgreement, "statsAgreement");
                } catch (err) {
                    console.log('problem generating table with stats_agreement');
                }


            }

            if (statsPlottingLoaded) {
                try {
                    filteredStatsPlotting = stats_plotting.filter(row => row.lemma === onlyLemma);
                } catch (err) {
                    console.log('stats_plotting not found');
                }

                try {
                    generateTable(filteredStatsPlotting, "statsPlotting");
                } catch (err) {
                    console.log('problem generating table with stats_plotting');
                }

                nodePosition = filteredStatsPlotting[0].node_position;
            }

            if (statsDataJointLoaded) {
                try {
                    filteredStatsDataJoint = data_joint.filter(row => row.lemma === onlyLemma);
                } catch (err) {
                    console.log('stats_data_joint not found');
                }

                try {
                    generateDetails(filteredStatsDataJoint, "statsDataJoint");
                } catch (err) {
                    console.log('problem generating table with statsDataJoint');
                }

                if(!annotatorsContainer.hasChildNodes()){
                    fillAnnotatorsContainer(filteredStatsDataJoint);
                }
            }

            noise_cluster_count = 0;
            nodes.forEach(function (node) {
                if (Number(node.label) == -1) {
                    noise_cluster_count += 1;
                }
            });

            clusterInfo = document.getElementById("clusterInfo");
            statisticsDiv = document.getElementById("statistics");

            clusterInfo.innerHTML = `
            <p>Node position: ${nodePosition}</p>
            <p>Clustering method: ${clusteringMethod}</p>`;

            statisticsDiv.innerHTML = `
            <p id="clusterFreqDist">Cluster frequency distribution: ${cluster_freq_dist}</p>
            <p id="clusterProbDist">Cluster probability distribution: ${cluster_prob_dist}</p>
            <p id="noiseClusterCount">Noise Cluster: [${noise_cluster_count}]</p>`;

        }


        function generateTable(jsonData, id) {
            if (!jsonData || jsonData.length === 0) {
                console.error(`Error: Invalid JSON data in generateTable function for id '${id}'`);
                return;
            }

            let div = document.createElement('div');


            let keys = Object.keys(jsonData[0]);
            keys.forEach(function (key) {
                let details = document.createElement('details');
                details.classList.add('shifted');
                let summary = document.createElement('summary');
                summary.innerText = key;
                details.appendChild(summary);
                let content = document.createElement('div');
                content.innerText = jsonData[0][key];
                details.appendChild(content);
                div.appendChild(details);

            })

            document.getElementById(id).append(div);
        }

        function generateDetails(jsonData, id) {
            let div = document.createElement('div');

            for (let i = 0; i < jsonData.length; i++) {
                let surroundingDetails = document.createElement('details');
                surroundingDetails.classList.add('shifted');
                let surroundingSummary = document.createElement('summary');
                surroundingSummary.innerText = i.toString();
                surroundingDetails.appendChild(surroundingSummary);
                div.appendChild(surroundingDetails);
                let keys = Object.keys(jsonData[i]);
                keys.forEach(function (key) {
                    let details = document.createElement('details');
                    details.classList.add('shifted');
                    let summary = document.createElement('summary');
                    summary.innerText = key;
                    details.appendChild(summary);
                    let content = document.createElement('div');
                    content.innerText = jsonData[i][key];
                    details.appendChild(content);
                    surroundingDetails.appendChild(details);

                })
            }

            document.getElementById(id).append(div);
        }




        function updateClusterDistribution() {
            let clusterFreqDist = [];
            let clusterProbDist = [];
            let noiseClusterCount = 0;
            let temp = [];
            let numberOfNodes = 0;

            nodes.forEach(function (node) {
                if (!node.hidden) {
                    temp.push(Number(node.label));
                }


            })

            temp.sort();

            let biggestLabel = temp[temp.length - 1];

            for (let i = 0; i <= biggestLabel; i++) {
                clusterFreqDist.push(0);
                clusterProbDist.push(0);
            }

            temp.forEach(function (item) {
                if (!(item == -1)) {
                    numberOfNodes += 1;
                    clusterFreqDist[item] += 1;
                } else {
                    noiseClusterCount += 1;
                }
            })

            for (let j = 0; j < clusterFreqDist.length; j++) {
                if (clusterFreqDist[j] > 0) {

                    clusterProbDist[j] = (clusterFreqDist[j] / numberOfNodes);

                    let parts = clusterProbDist[j].toString().split('.');

                    // Check the length of the decimal part
                    if (parts[1] && parts[1].length > 5) {
                        // Round the value to 5 decimal places if the decimal part is longer than 5 digits
                        clusterProbDist[j] = clusterProbDist[j].toFixed(5);
                    }
                }
            }

            document.getElementById("clusterFreqDist").innerHTML = "Cluster frequency distribution: [" + clusterFreqDist.toString() + "]";
            document.getElementById("clusterProbDist").innerHTML = "Cluster probability distribution: [" + clusterProbDist.toString() + "]";
            document.getElementById("noiseClusterCount").innerHTML = "Noise cluster: [" + noiseClusterCount.toString() + "]";
        }


        let annotatorsContainer = document.getElementById("annotatorsContainer");
        let annotators = [];

        function fillAnnotatorsContainer(jsonData) {
            let div = document.createElement('div');
            let h4 = document.createElement('h4');
            h4.innerHTML = "Annotator filter (resets all other filters): ";
            div.appendChild(h4);

            for (let i = 0; i < jsonData.length; i++) {

                let annotator = jsonData[i]["annotator"]
                if (!annotators.includes(annotator)) {
                    annotators.push(annotator);
                }
            }

            annotators.sort();

            for (let j = 0; j < annotators.length; j++) {
                let label = document.createElement('label');
                label.innerHTML = annotators[j];
                label.for = annotators[j];
                let checkbox = document.createElement('input');
                checkbox.type = "checkbox";
                checkbox.checked = true;
                checkbox.id = annotators[j];
                div.appendChild(label);
                div.appendChild(checkbox);
            }

            let button = document.createElement('button');
            button.innerHTML = "Show graph";
            button.onclick = annotatorsFilter;
            div.appendChild(button);
            let br = document.createElement('br')
            let br2 = document.createElement('br')
            div.appendChild(br);
            div.appendChild(br2);

            annotatorsContainer.append(div);
        }



        function annotatorsFilter() {
            showSelectLoad();
            setTimeout(calculateSubGraph, 1000);


            setTimeout(hideSelectLoad, 2000);


        }

        function calculateSubGraph() {
            loadingIcon.style.visibility = 'visible';
            let onlyCheckedAnnotators = [];
            for (let i = 0; i < annotators.length; i++) {
                let checkAnnotator = document.getElementById(annotators[i]);
                if (checkAnnotator.checked) {
                    onlyCheckedAnnotators.push(annotators[i]);
                }
            }


            let filteredForAnnotators = filteredStatsDataJoint.filter(row => onlyCheckedAnnotators.includes(row.annotator));


            groupPicker.selectedIndex = 0;
            sliderMin.value = 1;
            slider.value = 4;
            sliderDisplay.innerHTML = "4";
            sliderMinDisplay.innerHTML = "1";
            checkboxNoiseLabels.checked = true;
            checkboxNaN.checked = true;
            maxPicker.selectedIndex = dates.length - 1;
            minPicker.selectedIndex = 0;
            minValue = minPicker.value;
            maxValue = maxPicker.value;

            nodes.forEach(function (node){
                if(node.hidden){
                    node.hidden = false;
                    nodes.update(node);
                }
            })

            /*edges.forEach(function (edge) {
                let to = nodes.get(edge.to);
                let to_id = to.id;

                let from = nodes.get(edge.from);
                let from_id = from.id;

                let edgeAnnotations = [];

                for (let k = 0; k < filteredForAnnotators.length; k++) {
                    let item = filteredForAnnotators[k];
                    let identifier1 = item.identifier1;
                    let identifier2 = item.identifier2;
                    let weight = Number(item.judgment);

                    if((identifier1 == to_id && identifier2 == from_id) || (identifier1 == from_id && identifier2 == to_id)){

                        if(0 < weight < 5){
                            //console.log("there is a corresponding annotation thats not NaN");
                            edgeAnnotations.push(weight);
                        }
                    }
                }

                if (edgeAnnotations.length !== 0){
                let median;
                let filteredArray = edgeAnnotations;
                filteredArray.sort((a, b) => a - b);
                let middle = Math.floor(filteredArray.length / 2);
                if (filteredArray.length % 2 === 0) {
                    median = (filteredArray[middle - 1] + filteredArray[middle]) / 2;
                } else {
                    median = filteredArray[middle];
                }

                    console.log("the median for this edge is: " + median);

                    if (median == 0){
                        median = NaN;
                    }

                    edge.hidden = false;
                    edge.weight = median;
                    edge.label = edge.weight;

                    edges.update(edge);

                    } else {
                    edge.hidden = true;
                    edges.update(edge);
                }







            })
            */


            // Create a map to store the filteredForAnnotators array
            let annotationsMap = new Map();
            filteredForAnnotators.forEach(function (item) {
                let identifier1 = item.identifier1;
                let identifier2 = item.identifier2;
                let weight = Number(item.judgment);
                if (weight >= 0 && weight < 5) {
                    // Only store annotations with weight between 0 and 5
                    let key = [identifier1, identifier2].sort().join('-');
                    let annotations = annotationsMap.get(key) || [];
                    annotations.push(weight);
                    annotationsMap.set(key, annotations);
                }
            });

            // Iterate over the edges and get the annotations from the map
            edges.forEach(function (edge) {
                let to = nodes.get(edge.to);
                let to_id = to.id;
                let from = nodes.get(edge.from);
                let from_id = from.id;
                let key = [to_id, from_id].sort().join('-');
                let edgeAnnotations = annotationsMap.get(key) || [];


                    //console.log("edge annos: " + edgeAnnotations);

                if (edgeAnnotations.length !== 0) {
                    let median;
                    let filteredArray = edgeAnnotations.filter(a => a > 0);
                    filteredArray.sort((a, b) => a - b);

                    if (filteredArray.length === 0) {
                        median = 0;
                    } else {
                        let middle = Math.floor(filteredArray.length / 2);
                        if (filteredArray.length % 2 === 0) {
                            median = (filteredArray[middle - 1] + filteredArray[middle]) / 2;
                        } else {
                            median = filteredArray[middle];
                        }
                    }


                    //console.log("the median for this edge is: " + median);

                    if (median == 0) {
                        median = NaN;
                    }

                    edge.hidden = false;
                    edge.weight = median;
                    edge.label = edge.weight;

                } else {
                    edge.hidden = true;
                }

                edges.update(edge);
            });



            loadingIcon.style.visibility = 'hidden';

            calcMean();
            updateClusterDistribution();
        }


        sliderMin.value = 1;
        slider.value = 4;


    </script>
</body>

</html>