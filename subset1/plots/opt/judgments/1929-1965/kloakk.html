<html xmlns="http://www.w3.org/1999/html">

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.16.1/vis.css" type="text/css" />
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.16.1/vis-network.min.js"> </script>
    <center>
        <h1 id="heading">kloakk (1929-1965)</h1>
    </center>


    <!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->

    <style type="text/css">
       #mynetwork {
            width: 65%;
            height: 90%;

            margin-right: 2%;

            height: {
                    {
                    height
                }
            }

            ;

            background-color: {
                    {
                    bgcolor
                }
            }

            ;
            border: 1px solid lightgray;
            position: relative;
            float: left;
        }

            {
            % if nodes|length>100 and physics_enabled %
        }

        #loadingBar {
            position: absolute;
            top: 0px;
            left: 0px;

            width: {
                    {
                    width
                }
            }

            ;

            height: {
                    {
                    height
                }
            }

            ;
            background-color:rgba(200, 200, 200, 0.8);
            -webkit-transition: all 0.5s ease;
            -moz-transition: all 0.5s ease;
            -ms-transition: all 0.5s ease;
            -o-transition: all 0.5s ease;
            transition: all 0.5s ease;
            opacity:1;
        }

        #bar {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 20px;
            height: 20px;
            margin: auto auto auto auto;
            border-radius: 11px;
            border: 2px solid rgba(30, 30, 30, 0.05);
            background: rgb(0, 173, 246);
            /* Old browsers */
            box-shadow: 2px 0px 4px rgba(0, 0, 0, 0.4);
        }

        #border {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 500px;
            height: 23px;
            margin: auto auto auto auto;
            box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        #text {
            position: absolute;
            top: 8px;
            left: 530px;
            width: 30px;
            height: 50px;
            margin: auto auto auto auto;
            font-size: 22px;
            color: #000000;
        }

        div.outerBorder {
            position: relative;
            top: 400px;
            width: 600px;
            height: 44px;
            margin: auto auto auto auto;
            border: 8px solid rgba(0, 0, 0, 0.1);
            background: rgb(252, 252, 252);
            /* Old browsers */
            background: -moz-linear-gradient(top, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* FF3.6+ */
            background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, rgba(252, 252, 252, 1)), color-stop(100%, rgba(237, 237, 237, 1)));
            /* Chrome,Safari4+ */
            background: -webkit-linear-gradient(top, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* Chrome10+,Safari5.1+ */
            background: -o-linear-gradient(top, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* Opera 11.10+ */
            background: -ms-linear-gradient(top, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* IE10+ */
            background: linear-gradient(to bottom, rgba(252, 252, 252, 1) 0%, rgba(237, 237, 237, 1) 100%);
            /* W3C */
            filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fcfcfc', endColorstr='#ededed', GradientType=0);
            /* IE6-9 */
            border-radius: 72px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);
        }

            {
            % endif %
        }

            {
            % if conf %
        }

        #config {
            float: left;
            width: 400px;
            height: 600px;
        }

            {
            % endif %
        }

            {
            % if tooltip_link %
        }

        /* position absolute is important and the container has to be relative or absolute as well. */
        div.popup {
            position: absolute;
            top: 0px;
            left: 0px;
            display: none;
            background-color: #f5f4ed;
            -moz-border-radius: 3px;
            -webkit-border-radius: 3px;
            border-radius: 3px;
            border: 1px solid #808074;
            box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);
        }



        /* hide the original tooltip */


        .vis-tooltip {
            position: absolute;
        }

        #config {
            display: none;

        }

            {
            % endif %
        }

        #custom_wugs {
            height: 90%;
            width: 30%;
            overflow: scroll;
        }

        #custom_wugs>* {
            padding: 1%;
            margin-left: 2%;
        }






        .help-tip {
            position: absolute;
            top: 18px;
            right: 18px;
            text-align: center;
            background-color: #E55B0A;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 26px;
            cursor: default;
        }

        .help-tip:before {
            content: '?';
            font-weight: bold;
            color: #fff;
        }

        .help-tip:hover p {
            display: block;
            transform-origin: 100% 0%;

            -webkit-animation: fadeIn 0.3s ease-in-out;
            animation: fadeIn 0.3s ease-in-out;

        }

        .help-tip p {
            /* The tooltip */
            display: none;
            text-align: left;
            background-color: #1E2021;
            padding: 20px;
            width: 800px;
            position: absolute;
            border-radius: 3px;
            box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.2);
            right: 16px;
            color: #FFF;
            font-size: 13px;
            line-height: 1.4;
        }

        .help-tip p:before {
            /* The pointer of the tooltip */
            position: absolute;
            content: '';
            width: 0;
            height: 0;
            border: 6px solid transparent;
            border-bottom-color: #1E2021;
            right: 10px;
            top: -12px;
        }

        .help-tip p:after {
            /* Prevents the tooltip from being hidden */
            width: 100%;
            height: 40px;
            content: '';
            position: absolute;
            top: -40px;
            left: 0;
        }


        /* CSS animation */

        @-webkit-keyframes fadeIn {
            0% {
                opacity: 0;
                transform: scale(0.6);
            }

            100% {
                opacity: 100%;
                transform: scale(1);
            }
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 100%;
            }
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .loading-icon {
            position: absolute;
            top: 40%;
            left: 30%;
            transform: translate(-50%, -50%);
            border: 16px solid #f3f3f3; /* Light grey */
            border-top: 16px solid red;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
            visibility: hidden;
        }

        #custom_wugs {
            font-size: smaller;
        }

        .shifted {
            margin-left: 3%;
        }

        .bold {
            font-weight: bold;
        }

        #fillSD {
            margin-bottom: 0;
            padding-bottom: 0;
        }

    </style>

</head>

<body>
     <div id="loader" style="display: none"></div>

    <div id="mynetwork"></div>
    
    

    <div id="custom_wugs">



        <div class="help-tip">
            <p><em>General</em><br />
           Firefox is the recommended browser for this application. For large graphs, loading time may vary. This application is under development. Feedback is appreciated. The code, from which you can generate your own graphs, can be found here:  <a href="https://github.com/Garrafao/WUGs/" target="_blank" style="color: white">WUGs repository</a><br /><br /><br />
                <em>Statistics</em><br />
            The statistics section gets updated as the filters are used. For in-depth stats, refer to the stats dropdowns on the bottom.<br /><br /><br />
                <em>Edge & node filters</em><br />
            Edge weights are calculated as the mean of all annotations of the node pair.
            Nodes with noisy data appear black and have -1 as their label. Both the noisy nodes and edges with wrongly calculated weights can be filtered out.
            Edge and node filters are interlinked and should show the desired selection. While one filter is being calculated, the page will prevent you from selecting another filter.<br /><br /><br />
                <em>Annotators filter</em><br />
            The annotators filter resets all other filters and shows the initial graph, but only edges the selected annotators have annotated.</p>
        </div>

        <div class="infoContainer">
            <h4>Info: </h4>
            <div id="clusterInfo"></div>
            <h4>Statistics:</h4>
            <div id="statistics"></div>
            <p id="fillMean">Edge weight mean: </p>
            <p id="fillSD">Edge weight standard deviation: </p>
        </div>
        <div class ="edgeFilterContainer">
            <h4>Edge filters: </h4>

            <label for="checkboxNaN">Show NaN edges </label>
            <input type="checkbox" id="checkboxNaN" onclick="filterNaN()">
            <br><br>
            <div class="slideContainer" style="display: block; clear: both">
                <label for="slider-min" style="display: block">Min weight: <span id="sliderValueDisplayMin" style="display: inline-block">1</span></label>
                <input type="range" min="1" max="4" value="1" class="slider-load" id="slider-min">
                <label for="slider" style="display: block">Max weight: <span id="sliderValueDisplay" style="display: inline-block">4</span></label>
                <input type="range" min="1" max="4" value="4" class="slider-load" id="slider">
            </div>
        </div>




        <div class="nodeFilterContainer">
            <h4>Node filters: </h4>

            <label for="checkboxNoiseLabels">Show noise cluster</label>
            <input type="checkbox" id="checkboxNoiseLabels" onclick="filterNoiseLabels()">
            <br><br>
            <form onsubmit="dateFilter();return false">
                <label for="minPicker">From date: </label>
                <select class="picker" id="minPicker"></select>
                <label for="maxPicker">to date: </label>
                <select class="picker" id="maxPicker"></select>
                <input type="submit" value="Filter">
            </form>

            <label for="groupPicker">Grouping: </label>
            <select  class="select-load" id="groupPicker">
                <option>All</option>
                <option>1</option>
                <option>2</option>
            </select>
            <div class="loading-icon"></div>
        </div>

        <div id="annotatorsContainer"></div>

        <div class="detailsContainer">
            <details id="stats">
                <summary class="bold">Stats</summary>
                <table id="stats-table"></table>
            </details>
            <details id="statsGroupings">
                <summary class="bold">Grouping stats</summary>
                <table id="stats-groupings-table"></table>
            </details>
            <details id="statsAgreement">
                <summary class="bold">Agreement stats</summary>
                <table id="stats-agreement-table"></table>
            </details>
            <details id="statsPlotting">
                <summary class="bold">Plotting stats</summary>
                <table id="stats-plotting-table"></table>
            </details>
            <details id="statsDataJoint">
                <summary class="bold">Annotator data</summary>
            </details>
        </div>

    </div>

    <div id="config">

    </div>

    
     <!--<script type="text/javascript" src="../stats.js"></script>
     <script type="text/javascript" src="../stats_agreement.js"></script>
     <script type="text/javascript" src="../stats_groupings.js"></script>
     <script type="text/javascript" src="../stats_plotting.js"></script>
     <script type="text/javascript" src="../data_joint.js"></script>-->

    <script type="text/javascript">
        // initialize global variables.
        var edges;
        var nodes;
        var network;
        var container;
        var options, data;


        // This method is responsible for drawing the graph, returns the drawn network
        function drawGraph() {
            var container = document.getElementById('mynetwork');

            

            // parsing and collecting nodes and edges from the python
            nodes = new vis.DataSet([{"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_131", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eFor bygninger der er opf\u00f8rt f\u00f8r lov av 26 mai 1899 tr\u00e5dte i\u003cbr\u003ekraft, men efter lov av 30 april 1880, blir reglene i sistnevnte lov\u003cbr\u003egjeldende. 10 5. Bestemmelsene i punkt 3 og 4 skal ogs\u00e5 bli \u00e5 bef\u00f8lge\u003cbr\u003en\u00e5r eldre vei inng\u00e5r i regulert gate. 17 Forandring av 17 januar 1930.\u003cbr\u003e\u00a7 48, ledd 3. 11 N\u00e5r gate hvis vedlikeholdelse ikke var overtatt av\u003cbr\u003ekommunen, da loven av 3 april 1880 tr\u00e5dte i kraft, i det hele eller\u003cbr\u003efor en del oparbeides for kommunens regning, skal de grunneiere som\u003cbr\u003eefter naervaerende vedtekts ikrafttreden p\u00e5 eiendommer, langs hviike\u003cbr\u003eoparbeidelse av gate med \u003cb\u003ekloakk\u003c/b\u003e er bekostet av kommunen, har\u003cbr\u003eopf\u00f8rt eller opf\u00f8rer nybygning eller tii- eller p\u00e5 bygning p\u00e5 eldre\u003cbr\u003es\u00e5dan, enhver for sin eiendoms vedkommende, refundere kommunen dens\u003cbr\u003eutlegg til oparbeidelse av gate. 12 Bel\u00f8pet betales innen 3 m\u00e5neder\u003cbr\u003eefter at opgave over st\u00f8rrelsen er meddelt, eller s\u00e5fremt henstand\u003cbr\u003e\u00f8nskes i h\u00f8ist 10 \u00e5rlige terminer mot at der svares 5 av hundre i\u003cbr\u003e\u00e5rlig rente av det til enhver tid tilbakest\u00e5ende bel\u00f8p. 13\u003cbr\u003eGrunneiernes forpliktelse skal dog ikke g\u00e5 videre enn til \u00e5 erstatte\u003cbr\u003ekommunen halvparten av dens utgifter ved oparbeidelse av gaten i en\u003cbr\u003ebredde av inntil 20 m og ved nedlegning av kloakkr\u00f8r av inntil 305 mm\u003cbr\u003ediameter. 14 \u00a7 48, 1e d d 6. Med hensyn til den en eiendom p\u00e5hvilende\u003cbr\u003eerstatningsplikt i anledning av iverksatt gateoparbeidelse blir der\u003cbr\u003eved kommunens foranstalt- ning \u00e5 avholde forn\u00f8den tingles- ning til\u003cbr\u003eanf\u00f8rsel p\u00e5 vedkommende eiendoms folium i panteregistret. 18 1 Mens \u00a7\u00a7\u003cbr\u003e46 og 47 omhandler grunnerhverveise og dermed sammenhengende sp\u00f8rsm\u00e5l,\u003cbr\u003eomhandler \u00a7 48 gateoparbeidelse.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_131\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -564.9816869840406, "y": -133.01863525961767}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_40", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eVed overdragelse av kommunale industritomter b\u00f8r det sikres at\u003cbr\u003evedkommende bygger p\u00e5 tomten innen en viss tidsfrist. 2. Ved offentlig\u003cbr\u003etilrettelegging av veg, vann og \u003cb\u003ekloakk\u003c/b\u003e for private tomtearealer\u003cbr\u003efor industri, b\u00f8r det avtales med eieren at kommunen har anledning til\u003cbr\u003e\u00e5 overta hele eller deler av arealet etter takst hvis byggingen ikke\u003cbr\u003eer p\u00e5begynt innen en viss tidsfrist.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_40\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -635.8731888858191, "y": -1309.892216919683}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_45", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eHelser\u00e5det nedla forbud mot bruk av drikkevann fra bekk som ble\u003cbr\u003eforurenset ved \u003cb\u003ekloakkene\u003c/b\u003e fra ovenforliggende\u003cbr\u003evillabebyggelse.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_45\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": 301.43775513546916, "y": -956.0822691111418}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_73", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eUnder krigs\u00e5rene har veilyset vaert ute av funksjon, og dette i\u003cbr\u003eforbindelse med blendingen av alle vinduer, gj\u00f8r det meget vanskelig \u00e5\u003cbr\u003eferdes utend\u00f8rs etter m\u00f8rkets frembrudd. Vi avslutter dette avsnitt\u003cbr\u003emed \u00f8nsket om at den dag ikke m\u00e5 vaere fjern da v\u00e5re 51 veilyslamper\u003cbr\u003eatter kan tennes, og m\u00f8rketiden er slutt. Vann og\u003cbr\u003e\u003cb\u003ekloakk\u003c/b\u003e.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_73\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": 940.2527574404023, "y": 1192.2517422604349}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_79", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eDer var nok av oppg\u00e5ver i vellet AU mens min siet med vei, vann\u003cbr\u003eog \u003cb\u003ekloakk\u003c/b\u003e meldte det elektriske ly, se- og s\u00e5 var det \u00e5 f\u00e5 det\u003cbr\u003einn til hjemmene, og sa var det vegbelysning. Baerumsbanen kom\u003cbr\u003estikkende, og linjevalget voldte store b\u00f8tger.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_79\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -1117.2447848605455, "y": 1068.5513990333518}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_47", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eInnleding av overvatn og grunnvatn som den nedenfor liggende\u003cbr\u003ekommune eller eiendom plikter \u00e5 avgi avl\u00f8p og som det er i dens egen\u003cbr\u003einteresse \u00e5 lede inn i \u003cb\u003ekloakken\u003c/b\u003e, anses som bruk av ledningen\u003cbr\u003efra dens egen og ikke fra den ovenfor liggende kommunes eller eiendoms\u003cbr\u003eside. De enkelte grunneiere anses \u00e5 bruke kloakken like meget hver,\u003cbr\u003ehvis det ikke er stor forskjell i vassmengden fra de enkelte\u003cbr\u003eeiendommer.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_47\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -1011.7159824880401, "y": -963.8767997289317}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_16", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eDen er bygget av sand i tilnaermelsesvis horisontale lag. Under\u003cbr\u003eanlegget av en \u003cb\u003ekloakk\u003c/b\u003e i Tynset sommeren 1939 viste det seg at\u003cbr\u003esandlaget dekker en ujevn moreneoverflate. Noen steder er sandlaget\u003cbr\u003ebare et par meter tykt, og derunder ligger bregrus med blokker. Ved\u003cbr\u003eArnemoen stikker bregruset endog opp gjennom sanden.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_16\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -286.5341204751977, "y": 787.8463716126189}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_77", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eDet er for tiden ikke meget veilys \u00e5 passe p\u00e5, det er kun\u003cbr\u003eblendingslampene som m\u00e5 fornyes en gang imellom. Arbeidet med\u003cbr\u003eveivedlikeholdet er sterkt hemmet, lukking av \u003cb\u003ekloakker\u003c/b\u003e m\u00e5 utst\u00e5\u003cbr\u003etil sementr\u00f8r kan skaffes, og andre oppg\u00e5ver m\u00e5 hvile.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_77\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -1552.3844100507292, "y": 495.9514782740698}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_80", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eDet tok nok tid med lukking av enkelte stinkende bekker, heit\u003cbr\u003eopp til de siste \u00e5rene minnes en jo Kirkedalsbekken, men ogs\u00e5 hva\u003cbr\u003e\u003cb\u003ekloakk\u003c/b\u003e ang\u00e5r kan en nok si at veldistriktet er \u0026lt;\u0026lt;vel\u003cbr\u003ebel\u00e5ten\u00bb for \u00e5 hente et uttrykk fra andre siden av Kjolen. Nar man\u003cbr\u003etenker tilbake p\u00e5 den f\u00f8rste tids vannbaenng far man de korrekte\u003cbr\u003eperspektiver.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_80\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": 348.52072650907627, "y": -233.7050806148824}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_108", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eDen rivende utvikling av boligbyggingen langs Lysakerelvas\u003cbr\u003eBaerumsside har gjort den avskjaerende \u003cb\u003ekloakk\u003c/b\u003e brennende\u003cbr\u003eaktuell.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_108\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": -164.1692375048489, "y": -216.440627923043}, {"color": "#377eb8", "date": "1929", "id": "1929-1965_kloakk_35", "label": "0", "physics": false, "shape": "circle", "size": 10, "title": "\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003eB\u00e5de T\u00f8yenbekken og H. l\u00f8p tidl. ut i Oslo havn, men s\u00e5 ble\u003cbr\u003eT\u00f8yenbekken ledet i \u003cb\u003ekloakk\u003c/b\u003e til Akerselva i 1877.\u003cspan style=\"color:#808080;\"\u003e\u003c/span\u003e\u003cp style=\"font-size:8px;\"\u003e\u003cbr\u003edate: 1929\u003cbr\u003egrouping: 1929-1965\u003cbr\u003eidentifier: 1929-1965_kloakk_35\u003cbr\u003etype: usage\u003cbr\u003epos: NN\u003c/p\u003e", "x": 65.69624171397201, "y": -1425.634272954373}]);
        edges = new vis.DataSet([{"color": "black", "from": "1929-1965_kloakk_131", "label": "4/4/-", "to": "1929-1965_kloakk_45", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_131", "label": "4/4/4", "to": "1929-1965_kloakk_40", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_131", "label": "4/4/4", "to": "1929-1965_kloakk_80", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_131", "label": "4/4/4", "to": "1929-1965_kloakk_77", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_131", "label": "4/4/-", "to": "1929-1965_kloakk_35", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_131", "label": "-/4/4", "to": "1929-1965_kloakk_108", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_131", "label": "-/4/-", "to": "1929-1965_kloakk_16", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_131", "label": "-/-/4", "to": "1929-1965_kloakk_73", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_40", "label": "4/-/-", "to": "1929-1965_kloakk_16", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_40", "label": "4/4/-", "to": "1929-1965_kloakk_77", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_40", "label": "4/4/-", "to": "1929-1965_kloakk_108", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_40", "label": "-/4/4", "to": "1929-1965_kloakk_47", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_40", "label": "-/4/-", "to": "1929-1965_kloakk_35", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_40", "label": "-/4/-", "to": "1929-1965_kloakk_80", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_40", "label": "-/-/4", "to": "1929-1965_kloakk_45", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_40", "label": "-/-/4", "to": "1929-1965_kloakk_79", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_45", "label": "4/3/4", "to": "1929-1965_kloakk_35", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_45", "label": "4/-/4", "to": "1929-1965_kloakk_16", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_45", "label": "4/-/4", "to": "1929-1965_kloakk_77", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_45", "label": "4/-/-", "to": "1929-1965_kloakk_47", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_45", "label": "-/4/-", "to": "1929-1965_kloakk_80", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_45", "label": "-/4/-", "to": "1929-1965_kloakk_108", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_73", "label": "3/4/4", "to": "1929-1965_kloakk_16", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_73", "label": "3/-/-", "to": "1929-1965_kloakk_108", "weight": 3.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_73", "label": "3/-/-", "to": "1929-1965_kloakk_47", "weight": 3.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_73", "label": "-/4/-", "to": "1929-1965_kloakk_35", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_73", "label": "-/4/-", "to": "1929-1965_kloakk_79", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_73", "label": "-/-/4", "to": "1929-1965_kloakk_80", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_79", "label": "4/4/4", "to": "1929-1965_kloakk_47", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_79", "label": "-/4/4", "to": "1929-1965_kloakk_77", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_79", "label": "-/4/-", "to": "1929-1965_kloakk_80", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_79", "label": "-/-/4", "to": "1929-1965_kloakk_108", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_47", "label": "4/4/-", "to": "1929-1965_kloakk_16", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_47", "label": "4/4/-", "to": "1929-1965_kloakk_108", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_47", "label": "4/-/4", "to": "1929-1965_kloakk_80", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_47", "label": "-/4/-", "to": "1929-1965_kloakk_35", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_16", "label": "4/3/4", "to": "1929-1965_kloakk_35", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_16", "label": "-/4/-", "to": "1929-1965_kloakk_80", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_16", "label": "-/-/4", "to": "1929-1965_kloakk_108", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_77", "label": "4/4/4", "to": "1929-1965_kloakk_108", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_77", "label": "-/3/4", "to": "1929-1965_kloakk_35", "weight": 3.5, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_77", "label": "-/4/-", "to": "1929-1965_kloakk_80", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_80", "label": "4/4/-", "to": "1929-1965_kloakk_108", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_80", "label": "4/4/-", "to": "1929-1965_kloakk_35", "weight": 4.0, "width": 4}, {"color": "black", "from": "1929-1965_kloakk_108", "label": "-/4/-", "to": "1929-1965_kloakk_35", "weight": 4.0, "width": 4}]);

        // adding nodes and edges to the graph
        data = { nodes: nodes, edges: edges };

        var options = {
    "configure": {
        "enabled": true,
        "filter": [
            "nodes",
            "edges"
        ]
    },
    "edges": {
        "color": {
            "inherit": false
        },
        "smooth": {
            "enabled": false,
            "type": "continuous"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": false,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

        

        
        // if this network requires displaying the configure window,
        // put it in its div
        options.configure["container"] = document.getElementById("config");
        

        network = new vis.Network(container, data, options);

        


        

        return network;

    }

        drawGraph();


        let nodesInTimePeriod = new Set();
        let edgesInTimePeriod = new Set();
        let edgesBelowWeight = new Set();
        let nodesInGrouping = new Set();
        let edgesInGrouping = new Set();
        let edgesToBeShown = new Set();
        let nodesToBeShown = new Set();

        edges.forEach(function (edge) {
            edgesBelowWeight.add(edge.id);
            edgesInGrouping.add(edge.id);
            edgesInTimePeriod.add(edge.id);
            edgesToBeShown.add(edge.id);
        })

        nodes.forEach(function (node) {
            nodesInTimePeriod.add(node.id);
            nodesInGrouping.add(node.id);
            nodesToBeShown.add(node.id);
        })


        function showEdges() {
            edgesToBeShown.forEach(function (edge) {
                edge.hidden = false;
                edges.update(edge);
            })
        }

        //Missing the loading icon
        //slider code from pyvis filter example
        // Handler event when slider changes

        let slider = document.getElementById('slider');
        let sliderMin = document.getElementById('slider-min');
        let sliderDisplay = document.getElementById('sliderValueDisplay');
        let sliderMinDisplay = document.getElementById('sliderValueDisplayMin');

        sliderDisplay.innerHTML = "4";
        sliderMinDisplay.innerHTML = "1";

        function weightFilter() {
            console.log("weight filter got called");
            // Get the value of the slider
            let sliderValue = slider.value;
            let sliderMinValue = sliderMin.value;

            // Display the selected value next to slider
            sliderDisplay.innerHTML = sliderValue;
            sliderMinDisplay.innerHTML = sliderMinValue;

            // Loop through the edges
            edges.forEach(function (edge) {
                // Check if the edge should be displayed based on its weight
                if (edge.weight <= sliderValue && edge.weight >= sliderMinValue) {
                    if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden) {
                        edgesBelowWeight.add(edge.id);
                        edge.hidden = false;
                        edges.update(edge);
                    }
                    // Edge should be displayed
                    // Unhide edge if it's hidden and update DataSet

                } else if (isNaN(edge.weight)) {
                    //console.log("its NaN")
                } else {

                    // Edge should not be displayed
                    // Hide edge if not already hidden and update DataSet
                    if (!edge.hidden) {
                        edgesBelowWeight.delete(edge.id);
                        edge.hidden = true;
                        edges.update(edge);
                    }
                }
            });


            calcMean();
        }



        //code for node date filter
        let dates = [];
        nodes.forEach(function (node) {
            date = node.date;
            if (!dates.includes(date)) {
                dates.push(date);
            }
        });
        dates.sort();


        //code for date slider
        let minDate = 10000;
        let maxDate = 0;

        let minPicker = document.getElementById('minPicker');
        let maxPicker = document.getElementById('maxPicker');

        if (!minPicker.hasChildNodes()) {
            dates.forEach(function (date) {
                if (Number(date) < minDate) {
                    minDate = Number(date);
                }
                if (Number(date) > maxDate) {
                    maxDate = Number(date);
                }


                let option = document.createElement('option');
                option.text = date;
                option.value = date;

                let option2 = document.createElement('option');
                option2.text = date;
                option2.value = date;

                minPicker.append(option);
                maxPicker.append(option2);

            })
        } else {
            minDate = Number(dates[0]);
            maxDate = Number(dates[dates.length-1]);
        }
        maxPicker.selectedIndex = dates.length - 1;



        function showSelectLoad() {
            return new Promise(function (resolve) {
                loadingIcon.style.visibility = 'visible';
                resolve();
            });
        }

        function hideSelectLoad() {
            return new Promise(function (resolve) {
                loadingIcon.style.visibility = 'hidden';
                resolve();
            });
        }



        const loadingIcon = document.querySelector('.loading-icon');
        const select = document.querySelector('.select-load');

        select.addEventListener('change', function () {
            showSelectLoad();
            setTimeout(selectGroup, 1000);


            setTimeout(hideSelectLoad, 1000);


        });

        //const slider_load = document.querySelector('.slider-load');

         slider.addEventListener('change', function() {
            showSelectLoad();
            setTimeout(weightFilter,1000);


            setTimeout(hideSelectLoad, 1000);


        });

         sliderMin.addEventListener('change', function() {
            showSelectLoad();
            setTimeout(weightFilter,1000);


            setTimeout(hideSelectLoad, 1000);


        });

        let groupPicker = document.getElementById('groupPicker');
        groupPicker.selectedIndex = 0;
        let minValue = minPicker.value;
        let maxValue = maxPicker.value;

        function selectGroup() {
            return new Promise(function (resolve, reject) {
                let selectValue = document.getElementById('groupPicker').value;

                console.log("grouping value: " + selectValue);

                if (selectValue == 1) {
                    nodes.forEach(function (node) {


                        if (node.title.includes("grouping: 1") && Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                            node.hidden = false;
                            nodes.update(node);
                        } else {
                            node.hidden = true;
                            nodes.update(node);
                        }
                    })
                } else if (selectValue == 2) {
                    nodes.forEach(function (node) {
                        if (node.title.includes("grouping: 2") && Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                            node.hidden = false;
                            nodes.update(node);
                        } else {
                            node.hidden = true;
                            nodes.update(node);
                        }
                    })
                } else {
                    nodes.forEach(function (node) {
                        if (Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                            node.hidden = false;
                            nodes.update(node);
                        } else {
                            node.hidden = true;
                            nodes.update(node);
                        }
                    })
                }
                loadingIcon.style.visibility = 'hidden';

                edges.forEach(function (edge) {
                    if (isNaN(edge.weight)) {
                        if (showNaNEdges && !nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden) {

                            edge.hidden = false;
                            edges.update(edge);
                        } else {
                            edge.hidden = true;
                            edge.hidden = true;
                            edges.update(edge);
                        }
                    } else if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden && !isNaN(edge.weight)) {
                        edgesInGrouping.add(edge.id);
                        edge.hidden = false;
                        edges.update(edge);
                    } else {
                        edgesInGrouping.delete(edge.id);
                        edge.hidden = true;
                        edges.update(edge);
                    }


                })
                loadingIcon.style.visibility = 'hidden';
                calcMean();
                updateClusterDistribution();
                resolve();
            });

        }

        function dateFilter() {
            showSelectLoad();
            setTimeout(pickDates, 1000);


            setTimeout(hideSelectLoad, 2000);


        }

        function pickDates() {
            loadingIcon.style.visibility = 'visible';

            let selectValue = document.getElementById('groupPicker').value;
            minValue = minPicker.value;
            maxValue = maxPicker.value;

            //console.log("showing dates between " + minValue + " and " + maxValue);

            if (selectValue == 1) {
                nodes.forEach(function (node) {


                    if (node.title.includes("grouping: 1") && Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                        node.hidden = false;
                        nodes.update(node);
                    } else {
                        node.hidden = true;
                        nodes.update(node);
                    }
                })
            } else if (selectValue == 2) {
                nodes.forEach(function (node) {
                    if (node.title.includes("grouping: 2") && Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                        node.hidden = false;
                        nodes.update(node);
                    } else {
                        node.hidden = true;
                        nodes.update(node);
                    }
                })
            } else {
                nodes.forEach(function (node) {
                    if (Number(node.date) >= Number(minValue) && Number(node.date) <= Number(maxValue) && (Number(node.label) !== -1 || (Number(node.label) == -1 && showNoiseLabels))) {
                        node.hidden = false;
                        nodes.update(node);
                    } else {
                        node.hidden = true;
                        nodes.update(node);
                    }
                })
            }

            edges.forEach(function (edge) {


                if (isNaN(edge.weight) && !showNaNEdges) {

                } else if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden && isNaN(edge.weight)){
                    edgesInTimePeriod.add(edge.id);
                    edge.hidden = false;
                    edges.update(edge);
                } else if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden && edge.weight >= sliderMin.value && edge.weight <= slider.value) {
                    edgesInTimePeriod.add(edge.id);
                    edge.hidden = false;
                    edges.update(edge);
                } else {
                    edgesInTimePeriod.delete(edge.id);
                    edge.hidden = true;
                    edges.update(edge);
                }


            })
            loadingIcon.style.visibility = 'hidden'


            calcMean();
            updateClusterDistribution();

        }

        let showNaNEdges = true;

        function filterNaN() {
            showSelectLoad();
            setTimeout(selectNaN, 1000);


            setTimeout(hideSelectLoad, 1000);

        };

        const checkboxNaN = document.getElementById("checkboxNaN");

        function selectNaN() {
            if (checkboxNaN.checked) {

                showNaNEdges = true;
                edges.forEach(function (edge) {
                    if (isNaN(edge.weight)) {
                        edge.hidden = false;
                        edges.update(edge);
                        pickDates();
                    }
                });
            } else {
                showNaNEdges = false;
                edges.forEach(function (edge) {
                    if (isNaN(edge.weight)) {
                        edge.hidden = true;
                        edges.update(edge);
                    }
                });
            }


        }


        const checkboxNoiseLabels = document.getElementById("checkboxNoiseLabels");

        document.getElementById("checkboxNaN").checked = true;
        document.getElementById("checkboxNoiseLabels").checked = true;

        let showNoiseLabels = true;

        function filterNoiseLabels() {
            showSelectLoad();
            setTimeout(selectNoiseLabels, 1000);


            setTimeout(hideSelectLoad, 1000);
        }

        function selectNoiseLabels() {
            if (checkboxNoiseLabels.checked) {

                showNoiseLabels = true;

                nodes.forEach(function (node) {
                    if (Number(node.label) == -1) {
                        node.hidden = false;
                        nodes.update(node);
                    }
                })

                edges.forEach(function (edge) {
                    if (!nodes.get(edge.to).hidden && !nodes.get(edge.from).hidden) {
                        if (isNaN(edge.weight) && !showNaNEdges) {
                            edge.hidden = true;
                            edges.update(edge);

                        } else {
                            edge.hidden = false;
                            edges.update(edge);
                        }
                    }
                })

            } else {

                showNoiseLabels = false;

                nodes.forEach(function (node) {
                    if (Number(node.label) == -1) {

                        node.hidden = true;

                        nodes.update(node);
                    }
                })

                edges.forEach(function (edge) {
                    if (nodes.get(edge.to).hidden || nodes.get(edge.from).hidden || (isNaN(edge.weight) && !showNaNEdges)) {

                        edge.hidden = true;
                        edges.update(edge);

                    }
                })

            }
            updateClusterDistribution();
        }


        let fillMean = document.getElementById("fillMean");
        let fillSD = document.getElementById("fillSD");


        function calcMean() {
            let edgeValues = [];
            edges.forEach(function (edge) {
                if (!edge.hidden) {
                    let label = parseFloat(edge.weight);
                    if (!isNaN(label)) {
                        edgeValues.push(label);
                    }
                }
            })

            let mean = edgeValues.reduce((a, b) => a + b, 0) / edgeValues.length;
            let sd = dev(edgeValues, mean);
            if (isNaN(mean)) {
                mean = 0;
            }
            if (isNaN(sd)) {
                sd = 0;
            }
            mean = mean.toFixed(5);
            sd = sd.toFixed(5);

            fillMean.innerHTML = "Edge weight mean: ";
            fillSD.innerHTML = "Edge weight standard deviation: "

            fillMean.append(mean);
            fillSD.append(sd);

        }


        // Javascript program to calculate the standard deviation of an array

        function dev(arr, mean) {

            // Assigning (value - mean) ^ 2 to every array item
            arr = arr.map((k) => {
                return (k - mean) ** 2
            })


            // Calculating the sum of updated array
            let sum = arr.reduce((acc, curr) => acc + curr, 0);


            // Returning the standard deviation
            return Math.sqrt(sum / arr.length)
        }

        calcMean();


        let heading = document.getElementById("heading").innerHTML;
        let onlyLemma = heading.replace(/ .*/, '');

        //NEW

        // set up flag variables to track which scripts have been loaded successfully
        let statsLoaded = false;
        let statsGroupingsLoaded = false;
        let statsAgreementLoaded = false;
        let statsPlottingLoaded = false;
        let statsDataJointLoaded = false;

        let filteredStats = [];
        let filteredStatsGroupings = [];
        let filteredStatsAgreement = [];
        let filteredStatsPlotting = [];
        let filteredStatsDataJoint = [];

        let clusteringMethod;
        let cluster_freq_dist;
        let cluster_prob_dist;
        let noise_cluster_count;
        let clusterInfo;
        let statisticsDiv;
        let nodePosition;


        // create event listeners for each script to set the corresponding flag when loaded
        document.addEventListener('statsLoaded', function () {
            console.log('stats.js is fully loaded!');
            statsLoaded = true;
            checkAllScriptsLoaded();
        });

        document.addEventListener('statsGroupingsLoaded', function () {
            console.log('stats_groupings.js is fully loaded!');
            statsGroupingsLoaded = true;
            checkAllScriptsLoaded();
        });

        document.addEventListener('statsAgreementLoaded', function () {
            console.log('stats_agreement.js is fully loaded!');
            statsAgreementLoaded = true;
            checkAllScriptsLoaded();
        });

        document.addEventListener('statsPlottingLoaded', function () {
            console.log('stats_plotting.js is fully loaded!');
            statsPlottingLoaded = true;
            checkAllScriptsLoaded();
        });

        document.addEventListener('statsDataJointLoaded', function () {
            console.log('data_joint.js is fully loaded!');
            statsDataJointLoaded = true;
            checkAllScriptsLoaded();
        });

        // load each script with the same function
        function loadScript(scriptUrl, eventName) {
            const script = document.createElement('script');
            script.src = scriptUrl;
            script.type = 'text/javascript';

            script.addEventListener('load', function () {
                console.log(scriptUrl + ' loaded successfully');
                document.dispatchEvent(new Event(eventName));
            });

            script.addEventListener('error', function () {
                console.log('Failed to load ' + scriptUrl);
                checkAllScriptsLoaded();
            });

            document.body.appendChild(script);
        }

        // call the loadScript function for each script you want to load
        loadScript('../stats.js', 'statsLoaded');
        loadScript('../stats_groupings.js', 'statsGroupingsLoaded');
        loadScript('../stats_agreement.js', 'statsAgreementLoaded');
        loadScript('../stats_plotting.js', 'statsPlottingLoaded');
        loadScript('../data_joint.js', 'statsDataJointLoaded');

        // check if all scripts have been loaded, and execute the code that depends on them if they have
        function checkAllScriptsLoaded() {

            if (statsLoaded) {
                try {
                    filteredStats = stats.filter(row => row.lemma === onlyLemma);
                } catch (err) {
                    console.log('stats not found');
                }

                try {
                    generateTable(filteredStats, "stats");
                } catch (err) {
                    console.log('problem generating table with stats');
                }

                try {
                    clusteringMethod = filteredStats[0].algorithm;
                } catch (err) {
                    console.log('filteredStats[0] not found');
                }



            }

            if (statsGroupingsLoaded) {
                try {
                    filteredStatsGroupings = stats_groupings.filter(row => row.lemma === onlyLemma);
                } catch (err) {
                    console.log('stats_groupings not found');
                }

                try {
                    generateTable(filteredStatsGroupings, "statsGroupings");
                } catch (err) {
                    console.log('problem generating table with stats_groupings');
                }

                cluster_freq_dist = filteredStatsGroupings[0].cluster_freq_dist;
                cluster_prob_dist = filteredStatsGroupings[0].cluster_prob_dist;
            }

            if (statsAgreementLoaded) {
                try {
                    filteredStatsAgreement = stats_agreement.filter(row => row.data === onlyLemma);
                } catch (err) {
                    console.log('stats_agreement not found');
                }

                try {
                    generateTable(filteredStatsAgreement, "statsAgreement");
                } catch (err) {
                    console.log('problem generating table with stats_agreement');
                }


            }

            if (statsPlottingLoaded) {
                try {
                    filteredStatsPlotting = stats_plotting.filter(row => row.lemma === onlyLemma);
                } catch (err) {
                    console.log('stats_plotting not found');
                }

                try {
                    generateTable(filteredStatsPlotting, "statsPlotting");
                } catch (err) {
                    console.log('problem generating table with stats_plotting');
                }

                nodePosition = filteredStatsPlotting[0].node_position;
            }

            if (statsDataJointLoaded) {
                try {
                    filteredStatsDataJoint = data_joint.filter(row => row.lemma === onlyLemma);
                } catch (err) {
                    console.log('stats_data_joint not found');
                }

                try {
                    generateDetails(filteredStatsDataJoint, "statsDataJoint");
                } catch (err) {
                    console.log('problem generating table with statsDataJoint');
                }

                if(!annotatorsContainer.hasChildNodes()){
                    fillAnnotatorsContainer(filteredStatsDataJoint);
                }
            }

            noise_cluster_count = 0;
            nodes.forEach(function (node) {
                if (Number(node.label) == -1) {
                    noise_cluster_count += 1;
                }
            });

            clusterInfo = document.getElementById("clusterInfo");
            statisticsDiv = document.getElementById("statistics");

            clusterInfo.innerHTML = `
            <p>Node position: ${nodePosition}</p>
            <p>Clustering method: ${clusteringMethod}</p>`;

            statisticsDiv.innerHTML = `
            <p id="clusterFreqDist">Cluster frequency distribution: ${cluster_freq_dist}</p>
            <p id="clusterProbDist">Cluster probability distribution: ${cluster_prob_dist}</p>
            <p id="noiseClusterCount">Noise Cluster: [${noise_cluster_count}]</p>`;

        }


        function generateTable(jsonData, id) {
            if (!jsonData || jsonData.length === 0) {
                console.error(`Error: Invalid JSON data in generateTable function for id '${id}'`);
                return;
            }

            let div = document.createElement('div');


            let keys = Object.keys(jsonData[0]);
            keys.forEach(function (key) {
                let details = document.createElement('details');
                details.classList.add('shifted');
                let summary = document.createElement('summary');
                summary.innerText = key;
                details.appendChild(summary);
                let content = document.createElement('div');
                content.innerText = jsonData[0][key];
                details.appendChild(content);
                div.appendChild(details);

            })

            document.getElementById(id).append(div);
        }

        function generateDetails(jsonData, id) {
            let div = document.createElement('div');

            for (let i = 0; i < jsonData.length; i++) {
                let surroundingDetails = document.createElement('details');
                surroundingDetails.classList.add('shifted');
                let surroundingSummary = document.createElement('summary');
                surroundingSummary.innerText = i.toString();
                surroundingDetails.appendChild(surroundingSummary);
                div.appendChild(surroundingDetails);
                let keys = Object.keys(jsonData[i]);
                keys.forEach(function (key) {
                    let details = document.createElement('details');
                    details.classList.add('shifted');
                    let summary = document.createElement('summary');
                    summary.innerText = key;
                    details.appendChild(summary);
                    let content = document.createElement('div');
                    content.innerText = jsonData[i][key];
                    details.appendChild(content);
                    surroundingDetails.appendChild(details);

                })
            }

            document.getElementById(id).append(div);
        }




        function updateClusterDistribution() {
            let clusterFreqDist = [];
            let clusterProbDist = [];
            let noiseClusterCount = 0;
            let temp = [];
            let numberOfNodes = 0;

            nodes.forEach(function (node) {
                if (!node.hidden) {
                    temp.push(Number(node.label));
                }


            })

            temp.sort();

            let biggestLabel = temp[temp.length - 1];

            for (let i = 0; i <= biggestLabel; i++) {
                clusterFreqDist.push(0);
                clusterProbDist.push(0);
            }

            temp.forEach(function (item) {
                if (!(item == -1)) {
                    numberOfNodes += 1;
                    clusterFreqDist[item] += 1;
                } else {
                    noiseClusterCount += 1;
                }
            })

            for (let j = 0; j < clusterFreqDist.length; j++) {
                if (clusterFreqDist[j] > 0) {

                    clusterProbDist[j] = (clusterFreqDist[j] / numberOfNodes);

                    let parts = clusterProbDist[j].toString().split('.');

                    // Check the length of the decimal part
                    if (parts[1] && parts[1].length > 5) {
                        // Round the value to 5 decimal places if the decimal part is longer than 5 digits
                        clusterProbDist[j] = clusterProbDist[j].toFixed(5);
                    }
                }
            }

            document.getElementById("clusterFreqDist").innerHTML = "Cluster frequency distribution: [" + clusterFreqDist.toString() + "]";
            document.getElementById("clusterProbDist").innerHTML = "Cluster probability distribution: [" + clusterProbDist.toString() + "]";
            document.getElementById("noiseClusterCount").innerHTML = "Noise cluster: [" + noiseClusterCount.toString() + "]";
        }


        let annotatorsContainer = document.getElementById("annotatorsContainer");
        let annotators = [];

        function fillAnnotatorsContainer(jsonData) {
            let div = document.createElement('div');
            let h4 = document.createElement('h4');
            h4.innerHTML = "Annotator filter (resets all other filters): ";
            div.appendChild(h4);

            for (let i = 0; i < jsonData.length; i++) {

                let annotator = jsonData[i]["annotator"]
                if (!annotators.includes(annotator)) {
                    annotators.push(annotator);
                }
            }

            annotators.sort();

            for (let j = 0; j < annotators.length; j++) {
                let label = document.createElement('label');
                label.innerHTML = annotators[j];
                label.for = annotators[j];
                let checkbox = document.createElement('input');
                checkbox.type = "checkbox";
                checkbox.checked = true;
                checkbox.id = annotators[j];
                div.appendChild(label);
                div.appendChild(checkbox);
            }

            let button = document.createElement('button');
            button.innerHTML = "Show graph";
            button.onclick = annotatorsFilter;
            div.appendChild(button);
            let br = document.createElement('br')
            let br2 = document.createElement('br')
            div.appendChild(br);
            div.appendChild(br2);

            annotatorsContainer.append(div);
        }



        function annotatorsFilter() {
            showSelectLoad();
            setTimeout(calculateSubGraph, 1000);


            setTimeout(hideSelectLoad, 2000);


        }

        function calculateSubGraph() {
            loadingIcon.style.visibility = 'visible';
            let onlyCheckedAnnotators = [];
            for (let i = 0; i < annotators.length; i++) {
                let checkAnnotator = document.getElementById(annotators[i]);
                if (checkAnnotator.checked) {
                    onlyCheckedAnnotators.push(annotators[i]);
                }
            }


            let filteredForAnnotators = filteredStatsDataJoint.filter(row => onlyCheckedAnnotators.includes(row.annotator));


            groupPicker.selectedIndex = 0;
            sliderMin.value = 1;
            slider.value = 4;
            sliderDisplay.innerHTML = "4";
            sliderMinDisplay.innerHTML = "1";
            checkboxNoiseLabels.checked = true;
            checkboxNaN.checked = true;
            maxPicker.selectedIndex = dates.length - 1;
            minPicker.selectedIndex = 0;
            minValue = minPicker.value;
            maxValue = maxPicker.value;

            nodes.forEach(function (node){
                if(node.hidden){
                    node.hidden = false;
                    nodes.update(node);
                }
            })

            /*edges.forEach(function (edge) {
                let to = nodes.get(edge.to);
                let to_id = to.id;

                let from = nodes.get(edge.from);
                let from_id = from.id;

                let edgeAnnotations = [];

                for (let k = 0; k < filteredForAnnotators.length; k++) {
                    let item = filteredForAnnotators[k];
                    let identifier1 = item.identifier1;
                    let identifier2 = item.identifier2;
                    let weight = Number(item.judgment);

                    if((identifier1 == to_id && identifier2 == from_id) || (identifier1 == from_id && identifier2 == to_id)){

                        if(0 < weight < 5){
                            //console.log("there is a corresponding annotation thats not NaN");
                            edgeAnnotations.push(weight);
                        }
                    }
                }

                if (edgeAnnotations.length !== 0){
                let median;
                let filteredArray = edgeAnnotations;
                filteredArray.sort((a, b) => a - b);
                let middle = Math.floor(filteredArray.length / 2);
                if (filteredArray.length % 2 === 0) {
                    median = (filteredArray[middle - 1] + filteredArray[middle]) / 2;
                } else {
                    median = filteredArray[middle];
                }

                    console.log("the median for this edge is: " + median);

                    if (median == 0){
                        median = NaN;
                    }

                    edge.hidden = false;
                    edge.weight = median;
                    edge.label = edge.weight;

                    edges.update(edge);

                    } else {
                    edge.hidden = true;
                    edges.update(edge);
                }







            })
            */


            // Create a map to store the filteredForAnnotators array
            let annotationsMap = new Map();
            filteredForAnnotators.forEach(function (item) {
                let identifier1 = item.identifier1;
                let identifier2 = item.identifier2;
                let weight = Number(item.judgment);
                if (weight >= 0 && weight < 5) {
                    // Only store annotations with weight between 0 and 5
                    let key = [identifier1, identifier2].sort().join('-');
                    let annotations = annotationsMap.get(key) || [];
                    annotations.push(weight);
                    annotationsMap.set(key, annotations);
                }
            });

            // Iterate over the edges and get the annotations from the map
            edges.forEach(function (edge) {
                let to = nodes.get(edge.to);
                let to_id = to.id;
                let from = nodes.get(edge.from);
                let from_id = from.id;
                let key = [to_id, from_id].sort().join('-');
                let edgeAnnotations = annotationsMap.get(key) || [];


                    //console.log("edge annos: " + edgeAnnotations);

                if (edgeAnnotations.length !== 0) {
                    let median;
                    let filteredArray = edgeAnnotations.filter(a => a > 0);
                    filteredArray.sort((a, b) => a - b);

                    if (filteredArray.length === 0) {
                        median = 0;
                    } else {
                        let middle = Math.floor(filteredArray.length / 2);
                        if (filteredArray.length % 2 === 0) {
                            median = (filteredArray[middle - 1] + filteredArray[middle]) / 2;
                        } else {
                            median = filteredArray[middle];
                        }
                    }


                    //console.log("the median for this edge is: " + median);

                    if (median == 0) {
                        median = NaN;
                    }

                    edge.hidden = false;
                    edge.weight = median;
                    edge.label = edge.weight;

                } else {
                    edge.hidden = true;
                }

                edges.update(edge);
            });



            loadingIcon.style.visibility = 'hidden';

            calcMean();
            updateClusterDistribution();
        }


        sliderMin.value = 1;
        slider.value = 4;


    </script>
</body>

</html>